"""
FIG. {figno} illustrates a block diagram of the {system} according to an embodiment of the invention. Generally, {system} comprises a communications interface (shown as network interface {figno}02), processor {figno}04, memory {figno}06 and optionally mass storage {figno}12 which all communicate using one or more data buses {figno}10, which can include internal data buses, external serial buses, universal serial bus (USB), peripheral component interconnect (PCI) bus, serial advanced technology attachment (SATA), and/or external SATA (eSATA), the implementation of which is apparent to one of ordinary skill in the art.
[0015]The communications interface {figno}02 is used to interface {system} to external devices{external}. In the depicted example, the interface is shown as network interface {figno}02 such as a network interface card (NIC). Network interface {figno}02 can be configured to carry data using the internet protocol (IP) with transmission control protocol (TCP) or user datagram protocol (UDP) and can be based on any number of data link protocols including but not limited to Ethernet, point-to-point protocol (PPP), high-level Data link control (HDLC) and advanced data communication control protocol (ADCCP). Alternatively or in addition, the communications interface can include other forms of inter-device communications including but not limited to universal serial bus (USB), IEEE-1394 (Firewire), eSATA, and/or high-definition multimedia interface (HDMI).

[0016]Mass storage {figno}12 can comprise any number of storage media including but not limited to a hard disk drive, solid state drive, flash memory, and or optical storage media. Mass storage {figno}12 is used to supplement memory {figno}06 and is often configured with files in a file system, but may also provide storage for virtual memory as an extension of memory {figno}06.
[0017]Processor {figno}04 can be any device for executing instructions, particularly instructions stored in memory {figno}06. Processor {figno}06 can comprise any commercially available processor such as a central processor unit (CPU), floating-point processor unit (FPU), graphics processing unit (GPU), a multicore processor, a microprocessor (either in the form of a microchip or chip set), a macroprocessor, or generally any device for executing software instructions. Or processor {figno}06 can comprise a custom made processing device such as one made from a programmable logic array (PLA), field programmable gate array (FPGA), application specific integrated circuit (ASIC), solution on a chip (SOC), or combination thereof.
[0018]Memory {figno}06 can comprise any one or combination of volatile memory elements such as random access memory (RAM) (for example, dynamic RAM (DRAM), static RAM (SRAM), synchronous dynamic RAM (SDRAM), double data rate (DDR) RAM, etc.) and/or nonvolatile memory elements such as read only memory (ROM, flash memory, hard drive, tape, optical media, etc.). In addition, memory {figno}06 can comprise various components such as program memory for storing processor instructions, data memory for storing data used by the processor {figno}04, and/or various levels of caches. It should be noted that mass storage {figno}12 and memory {figno}06 can share much of the same functionality, for example, program instructions can be stored both in mass storage {figno}12 and read into memory {figno}06 as the processor executes the program instructions. Therefore, one of ordinary skill in the art should note that though described separately in this embodiment, memory {figno}06 can perform any function described for mass storage {figno}12.
[0019]The software in memory {figno}06 can include one or more separate programs, each of which includes an ordered listing of executable instructions for implementing logical functions. Typically, the software in memory {figno}06 which may initially be stored in mass storage {figno}12, read into memory {figno}06 for execution by processor {figno}04, and can include operating system {figno}20. Executing within the operating system is application specific software {figno}22. It should be noted, however, that the modules within application specific software {figno}22 can be implemented in software, hardware or a combination of software and hardware. In addition to controlling and executing application specific software {figno}22, operating system {figno}20 can be configured to manage hardware resources including but not limited to input-output control, file and data management, memory management, communications controls and provide software services including but not limited to control the execution of other computer programs, scheduling, and inter-process communications.
[0020]Template database {figno}08 can be implemented either directly in memory {figno}06 or stored in mass storage {figno}12. Template database {figno}08 stores biometric templates which have been previously enrolled.
[0021]In {system}, application specific software {figno}22 comprises template manager {figno}60 and one or more biometric modules which can be implemented as a plug-in module. A plug-in module is a common interface to template manager {figno}60. By using a plug-in module, only a minor change to application specific software {figno}22 is needed to add additional biometric modules to the query engine. Often, biometric capabilities are provide by means of software development kits (SDK) which are typically proprietary applications provide by third parties. SDKs can be converted to a plug-in module by wrapping the application program interfaces (API) provide by the SDK into the common interface to template manager 260.
[00{figno}{figno}]Application specific software {figno}22 can also be provided and stored on a non-transient storage medium either for distribution or retrieval for execution by the processor when needed.
[0023]More specifically, in FIG. {figno}, these biometric modules are depicted as facial recognition plug-in {figno}30, iris recognition module plug-in 240, and fingerprint recognition module 250. Facial recognition plug-in 230 can comprise facial recognition SDK 232, which can be adapted to compare facial biometric templates and return a score that represents the degree of similarity of the templates. Iris recognition plug-in 240 can comprise iris recognition SDK 242, which can be adapted to compare iris biometric templates and return a score that represents the degree of similarity of the templates. Fingerprint recognition plug-in 250 can comprise fingerprint recognition SDK 252.
[0024]Biometric module plug-ins can be classified as either “normal” plug-ins or “pass-through” plug-ins. A normal plug-in is supplied probe and enrolled templates and returns a score based on the comparison between the probe and enrolled templates. This can be implemented by the wrapper functions within the plug-in providing the probe and enrolled templates to the underlying SDK for comparison and scoring and receiving scores from the underlying SDK. A pass-through plug-in receives enrollment templates during enrollment and only probe templates during verification or comparison. Essentially, all data is passed through directly to the underlying SDK. The primary difference between the two types of plug-ins is that in a normal plug-in biometric templates are stored in templates database 208 and retrieved by template manager 260 and provided to the plug-in for comparison and scoring and in a pass-through plug-in all information is passed through to the pass-through plug-in and the biometric templates are not stored in templates database 208 rather storage of the templates relies on the pass-through plug-in and in particular any underlying proprietary recognition module often provided in the form of an SDK. In the previous example, facial and iris recognition are commonly implemented as a normal plug-in and fingerprint recognition is commonly implemented as a pass-through plug-in.
[0025]Template manager 260 manages the templates database 208 where biometric templates are stored and retrieved for searches. Template manager 260can also determine which plug-in module is to be used. Template manager 260 can further comprise verification logic 262.
